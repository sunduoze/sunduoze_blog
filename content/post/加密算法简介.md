---
categories:
- 笔记
- 技术
date: 2021-09-13T13:46:04+08:00
description: Resonance,natural language communication
keywords:
- 其他
title: "加密算法简介"
url: ""
draft: false
math : true
mermaid : true
wavedrom : true
---

## 加密算法简介 

刘武光，Business Manager
Wuguang.Liu@MaximIntegrated.com

### 加密算法模型

* `$Y = f(x_1,x_2,...,x_n,Secret)$`
其中`$x_1,x_2,...x_n$`为输入明文数据，第三方可见；
Secret为密码，第三方不可见

* 加密算法通常包含逻辑运算（异或，以为，不带进位求和等）、求余，
某些特殊函数(如欧拉函数)等

* 2种算法输出结果类型Y

 > 产生密文Ye，通过对应的解密算法可以还原为原文$x_1,x_2,...,x_n$,用于内容加密和安全身份认证
 </br>
 > 生成摘要码（Digest Code），亦可称为数字签名信息（DSA）、认证信息码（MAX），用于安全身份认证


<script type="WaveDrom">
{assign:[
  ["算法输出Y",
    ["", ["算法函数",["","X1","X2","...","Xn","Secret"
    ],]]
  ]
]}
</script>

* 加密算法类型

> 对称加密算法：MD5 SHA-1 SHA-256 AES DES 3DES</br>
> 非对称加密算法：EC ECDSA RSA等

* 对称加密算法：

1. 收发采用相同密码运算
2. 存放的密码需要安全保管
3. 同安全等级下，加密算法较非对称算法简单从而更少的运算时间

* 非对称加密算法：

1. 收发采用不同密码进行运算（发送方使用公匙加密，接收方私匙解密；或接收方用私匙加密，发送方用公匙解密）
2. 由私匙生成公匙或由公匙生成私匙
3. 私匙需要妥善保管，公匙为公开信息，无需安全保存

#### SHA-x(SHA-1 ... SHA-512)

<div class="mermaid">
flowchart LR
  A[data] --> C[SHA];
  B[Secret] --> C;
  C --> D[MAC];
  style A fill:#f9f,stroke:#333,stroke-width:4px;
  style B fill:#f9f,stroke:#333,stroke-width:4px;
</div>

#### 非对称加密算法ECDSA P-192（Puk 签名 认证方程 域参数 G(x,y),p,n）

* 公匙（Puk）

1. 先确定私匙（随机生成）= `$d$`
2. 计算出公匙Puk: `$Q(x, y) = G(x, y) * d$`

* ECDSA器件签名信息（计算结果）：r,s

1. 主机输入数据源 = m
2. ECDSA从器件产生的随机数 = k
3. `$x_1,y_1 = [G(x,y)*k*]\mod\ p$`</br>
   `$r = x_1\mod\ n$`</br>
   `$s = [k^{-1}*(m+d*r)]\mod\ n$`</br>

* 主机认证ECDSA器件的签名信息

1. ECDSA器件的签名结果：r,s</br>
   `$ w = s^{-1}\ mod \ n$`</br>
   `$ u1 = [m * w]\ mod \ n$`</br>
   `$ u2 = [r * w]\ mod \ n$`</br>
   `$ (x_2,y_2) = [(u_1 * G(x,y)) + (u_2)*Q(x,y)]\ mod \ n$`</br>
   如果计算粗的`$x_2 = r$`, 则签名信息通过主机认证


#### ECDSA P-192加密算法

1. 椭圆形曲线`$F_p: \ y^2 = x^3 + ax + b$`
2. 算法参数定义：

|算法参数名称|符号|ECDSA P-192加密算法 hex数|
|:-:|:-:|:-:|
|素模|p|FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFFFF FFFFFFFF|
|素域|n|FFFFFFFF FFFFFFFF FFFFFFFF 99DEF836 146BC9B1 B4D22831|
|椭圆曲线系数a|a|FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFFFF FFFFFFFC|
|椭圆曲线系数b|b|64210519 E59C80E7 0FA7E9AB 72243049 FEB8DEEC C146B9B1|
|基点 x|Gx|188DA80E B03090F6 7CBF20EB 43A18800 F4FF0AFD 82FF1012|
|基点 y|Gy|07192B95 FFC8DA78 631011ED 6B24CDD5 73F977A1 1E794811|

* remark： 主机和加密器件采用相同的算法参数

#### 加密算法要求

1. 不可逆运算
2. 算法是公开的，标准的，便于广泛使用及第三方算法安全评估
3. 采用“穷举”算法攻击密码几乎不可能
4. 算法计算时要适度的资源和计算时间

#### 加密算法实际应用

* 数据加密和解密：

1. 常用算法：AES RSA 3DES
2. 典型应用：数据安全传输&存储等

* 安全身份认证：

1. 常用算法：所有加密算法均可用于认证，MD5 SHA-x EC ECDSA
2. 典型应用：要求安全身份识别的应用，如防伪，ID识别，系统配件识别

* 采用对称加密算法（Eg. AES-128）进行加密/解密流程

</br>
Remark:收发双方的使用的相同密码

<div class="mermaid">
flowchart TD
    A(发送方:128bits原文数据) --> B[加密算法AES-128];
    X(128位加密密码) --> B;
    B --> C[128bits密文数据到接收方];
    C -.-> D[来自发送方的128bits密文数据];
    D --> E[解密算法AES-128];
    E --> F[接收方:获得128bits原文数据];
    Y[128位解密密码] --> E;
    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style E fill:#f9f,stroke:#333,stroke-width:4px;
</div>

* 采用非对称加密算法（Eg. RSA-1024）进行加密/解密流程

Remark:</br>

1. 长度N < 1024
2. 只有接收方使用加密方提供的私钥条件下，接收方才能正确的解密出原文

<div class="mermaid">
flowchart TD
    A(发送方:N bits原文数据) --> B[加密算法RSA-1024];
    X(1024位加密公匙) --> B;
    B --> C[N bits密文数据到接收方];
    C -.-> D[来自发送方的N bits密文数据];
    D --> E[解密算法RSA-1024];
    E --> F[接收方:获得N bits原文数据];
    Y[1024位解密私匙] --> E;
    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style E fill:#f9f,stroke:#333,stroke-width:4px;
</div>

* 采用混合对称&非对称加密算法进行加密/解密流程

<div class="mermaid">
flowchart TD
    A[发送方:128 bits原文数据] --> B[加密算法AES-128];
    U[128位AES加密密码] --> B;
    B --> C[128 bits密文数据到接收方];
    C -.-> D[来自发送方的128 bits密文数据 & 128位密码密文];
    D --> E[解密算法AES-128];
    E --> F[接收方:获得128 bits原文数据];
    V[128位AES解密密码] --> E;
    U --> G[加密RSA算法];
    W[RSA加密公匙] --> G;
    G --> H[128位AES密码密文];
    H --> D;
    D --> I[解密RSA算法];
    I --> V;
    X[RSA解密私匙] --> I;
    
    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style E fill:#f9f,stroke:#333,stroke-width:4px;
    style G fill:#f9f,stroke:#333,stroke-width:4px;
    style I fill:#f9f,stroke:#333,stroke-width:4px;
</div>

* 采用对称加密算法（Eg. SHA-256）进行身份认证流程

Remark:</br>

1. 只有主机&从机密码相等，且输入明文数据被正确传输的条件下，
从机才能通过主机安全认证

<div class="mermaid">
flowchart TD
    A[256位主机密码] ==> B[安全算法SHA-256];
    B --主机计算结果--> C{计算结果一致吗?};
    C --是--> D[主机判断从机身份合法];
    C --否--> E[主机判断从机身份不合法];
    J[认证主机:输入明文数据] --> B;
    K[被认证从机:输入明文数据] --> I[安全算法SHA-256];
    H[256位从机密码] ==> I;
    I --从机计算结果--> C;

    J <-.-> K

    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style I fill:#f9f,stroke:#333,stroke-width:4px;
</div>

* 采用非对称加密算法（Eg. ECDSA-192）进行身份认证流程

Remark:</br>

1. 只有在主机使用的公匙是由合法从机私匙生成的条件下，从机才能获得主机的安全身份认证

<div class="mermaid">
flowchart TD
    A[192位主机公密] ==> B[安全算法ECDSA-192];
    B --主机计算结果:r',s'--> C{r' == r?};
    C --是--> D[主机判断从机身份合法];
    C --否--> E[主机判断从机身份不合法];
    J[认证主机:输入明文数据] --> B;
    K[被认证从机:输入明文数据] --> I[安全算法ECDSA-192];
    H[192位从机私钥] ==> I;
    I --从机计算结果:r,s--> B;

    J <-.-> K

    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style I fill:#f9f,stroke:#333,stroke-width:4px;
</div>

* 美信加密器件

1. 安全处理器（DS5250、MAXQ1850）
2. 安全认证加密器件（SHA-1 SHA-256 ECDSA三类）

#### 如何使用加密器件，包括2个步骤

1. 初始化加密器件--加载器件的密码

* 所有加密器件采用相同密码或公匙&私匙密码对
  缺：器件密码就是系统密码，一旦泄露整个系统安全性就崩溃
* 为每个器件加载唯一的密码或密码对
  优：器件密码不代表系统的安全性，单个器件密码泄露，但整个系统仍然安全

2. 认证环节：在应用程序中嵌入认证程序，以识别加密器件身份合法性

* 基于安全身份认证的加密器件不会对执行程序代码进行加密
* 基于随机数质询-响应机制，为每次认证过程产生的随机的算法结果，防止非法复现

#### SHA-1/SHA-2器件加载唯一密码流程

<div class="mermaid">
flowchart LR
  subgraph N[SHA-1/ SHA-2 加密器件]
    W[64bits ROM ID];
    X[...];
    Y[EEPROM];
    Z[器件密码];
    W --- X;
    X --- Y;
    Y --- Z;
  end
  A[系统主密码] --> B[SHA-1/SHA-2算法 or 客户自定义的密码算法];
  W --> B;
  B --> Z;
  style A fill:#f9f,stroke:#333,stroke-width:4px;
  style B fill:#f9f,stroke:#333,stroke-width:4px;
</div>

#### 利用随机数发生器为每个ECDSA器件加载唯一公匙与私匙对

<div class="mermaid">
flowchart LR
  subgraph N[ECDSA Engine]
    W[P-192 domain paraeters];
  end
  A[随机数生成器] --> N;
  A --192bits--> C[私匙];
  N --2*192bits--> D[公匙];
  style A fill:#f9f,stroke:#333,stroke-width:4px;
</div>


#### SHA 器件的随机质询-响应认证机制：

* Remark:主机基于器件的ROM ID和系统主密码计算出被认证器件的密码

<div class="mermaid">
flowchart TB

  subgraph 认证主机
  direction LR
    subgraph O[处理器]
      G[系统主密码] --> H[器件密码];
      H --> I[SHA Engine];
      J[器件明文数据] --> I;
    end
    Y[主机产生随机数] --> I;
  end

  subgraph 被认证器件
  direction LR
    subgraph Q[SHA加密器件]
      U[器件密码] --> V[SHA Engine];
      W[器件明文数据] --> V;
    end
  end

  Y --> V;
  I --> Z{==?};
  V --> Z;
  Z --是--> 从机通过认证;
  Z --否--> 从机未通过认证;

  style Y fill:#f9f,stroke:#333,stroke-width:4px;
  style Z fill:#f9f,stroke:#333,stroke-width:4px;
</div>


#### 不对称加密ECDSA器件DS28E35的随机质询-响应认证机制：

* Remark:只有在公钥和私钥配对的情况下，被认证的器件才能通过主机的认证

<div class="mermaid">
flowchart TB

  subgraph 认证主机
  direction LR
    subgraph O[处理器]
      H(器件明文数据) --> I(SHA Engine);
      I --> J(ECDSA_Verfiy);
      K(器件公匙) --> J;
      J --> L{Yes or No};
    end
    Y(主机产生随机数) --> I;
  end
%% dajfkhfdkdahf
  subgraph 被认证器件
  direction LR
    subgraph Q[SHA加密器件]
      U(器件明文数据) --> V[SHA Engine];
      V --> W(ECDSA_Sign);
      RNG --> W;
      X(器件私钥) --> W;
    end
  end

  W --> J;
  Y --> V;
  
  style Y fill:#f9f,stroke:#333,stroke-width:4px;
  style L fill:#f9f,stroke:#333,stroke-width:4px;
</div>

#### 加密器件应用领域

1. 软件代码（IP）保护
2. 软件授权&升级管理
3. 配件识别&电子标签
4. 网上身份识别
5. 低成本USB-key解决方案
6. 有源RFID
7. 数据传输&媒体文件的加解密

* 打印机相关等耗材管理（真伪 & 用量）

* 电池（真伪 & 特性参数）

* 医疗传感器（真伪 & 校准参数）

* FPGA IP保护

* 低成本 USB-Key 解决方案---基于SHA-1/SHA-256 或者 ECDSA 加密器件，采用USB-UART控制器，无须额外的软件设计</br>
SHA-1 DS28E10/DS28E01-100,SHA-256 DS28E15/22/25或者ECDSA加密算法的DS28E35

* 数据传输加/密& 媒体文件数字版权保护（DRM）
